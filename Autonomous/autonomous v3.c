#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     liftLeftBottom, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     liftLeftTop,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftRightTop,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     liftRightBottom, tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    latchRight,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    latchLeft,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    intakeLeft,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_4,    intakeRight,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* February 9th, 2015
* Chris: Updates and what-nots

February 13th, 2015
Chris: Friday the 13th... Competition tomorrow... I came in 1st and 3rd period to tune the PID, and it's ALRiGHT I guess,
though I had to take out the proportional controller for driving (like, slowing down when approaching set-point), because
it went too slow for the PID to tune I guess. Not sure.
*/

#define BOUND(num, low, high) (num < low) ? low : ((num > high) ? high : num)   //We don't want to set the motors higher than -100 or 100, so limit it!
const float ENCODER_TICKS_PER_INCH = 152.788745368;	//[1440 / wheel circumference (in inches)]
const int perfect90 = 1980; // [16.5 inches * pi (circle that a point turn makes) / 4 (90 degrees is 360 degrees divided by 4)] * ENCODER_TICKS_PER_INCH
int turnFactor = 0;
int encoderDist = 0;

const float kp = .3;	//Proportional constant for driving straight
const float ki = .001;	//Integral constant for driving straight
const float kd = 1.8;	//Derivative constant for driving straight
const float kpd = 1;	//Proportional constant for driving a certain distance (slowing down as approaching)
short controllable = 1000;	//Only use PID if the error is within the controllable range
short lastError = 0;
short error = 0;	//error is difference between the two motors
short distError = 0;	//distError is the (set point - average of encoders)
short integral = 0;	//Sum of all past errors
short derivative = 0;	//Rate of change ("slope"/"prediction")
short speed = 0;

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

int chooseStrategy();
int chooseStart();
int chooseGoals();
int chooseDelays();
bool isTestRun();

void moveStraight(int distInInches, int scaleFactor=1);
void turn(int turnFactor, int encoderDist);	//If turn factor is negative, turn left. If positive, turn right
void trackForIR();	//ASSUMES: the robot is parallel to the center goal (IR is facing the first-position-beacon
void latchDown();
void latchUp();
void smoothTurn(bool turnRight);
void downRamp();

task main()
{
	stopTask(displayDiagnostics);
	eraseDisplay();
	int strategy = chooseStrategy();	//1=nothing, 2=points, 3=defend[start on parking zone]
	int startSpot = chooseStart();	//1=platform, 2=parking zone
	int goals = chooseGoals();	//1=60cm, 2=30cm, 3=both, 4=none
	int delayTime = chooseDelays();	//1=0sec, 2=1sec, 3=4sec, 4=9sec, 5=16sec
	bool wait4Start = isTestRun();

	if(wait4Start) waitForStart();
	if(delayTime > 1) wait1Msec(delayTime * 1000);	//Wait for start if it's not a test run, then wait the delay

	if(strategy == 1)	//Do nothing if selected strat is 1
	{
	downRamp();
	}
	else if(strategy == 2)	//Score points if selected strat is 2
	{
		if(startSpot == 1)	//Initiate scoring based on platform
		{
			motor[liftLeftBottom] = 50;
			motor[liftLeftTop] = -50;	//Reversed b/c leftFront encoder is plugged into this
			motor[liftRightBottom] = 50;
			motor[liftRightTop] = 50;
			wait1Msec(250);
			motor[liftLeftBottom] = 0;
			motor[liftLeftTop] = 0;
			motor[liftRightBottom] = 0;
			motor[liftRightTop] = 0;

			downRamp();
			motor[frontLeft] = 0;
			motor[frontRight] = 0;
			motor[backLeft] = 0;
			motor[backRight] = 0;

			latchDown();

			//Should we do smooth turns or point/pivot turns? Which one would be more accurate?
			smoothTurn(true);
			moveStraight(5);
			smoothTurn(false);

			moveStraight(20);
		}
		else if(startSpot == 2)	//Initiate scoring based on parking zone
		{

		}
	}
	else if(strategy == 3)	//Defend if selected strat is 3
	{

	}
}

//Use PID to move straight! Scale factor makes it slower (E.G scaleFactor of 2 makes it at half speed)
void moveStraight(int distInInches, int scaleFactor)
{
	int turnFactor = 0;
	int encoderDist = distInInches * ENCODER_TICKS_PER_INCH;
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(abs((nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2) < abs(encoderDist))
	{
		//Only do PID if the motors are within the controllable range
		if (abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) < 3000 && abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) > 100)
		{
			//Error is the difference between the encoders
			error = nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];

			integral += error;	//Add error to integral
			if(integral > 2000) integral = 2000;
			else if(integral < -2000) integral = -2000;	//Limit the integral
				//integral = (int)((integral * 2/3) + error);	//Dampen integral and add error
			derivative = error - lastError;	//Find the slope (rate of change)
			lastError = error;	//Update lastError for the next run-thru

			//Add the P.I.D terms to determine how much to turn the robot to get it to go straight
			turnFactor = (int)((error * kp) + (integral * ki) + (derivative * kd));
		}
		else
		{
			turnFactor = 0;
		}
		//Error of distance is the (set point - average of encoders)
		distError = encoderDist - (nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2;

		//speed = BOUND((int) distError * kpd, -50, 50);	//Limit so we have some room for the turnFactor
		/*Since turnFactor is basically the difference between the left and right motors, we'll
		add it to the right motors and subtract it from the left motors. When inversed, it'll still work*/
		if(sgn(encoderDist)==1)
		{
			motor[frontLeft] = (50 - turnFactor) / scaleFactor;
			motor[frontRight] = (50 + turnFactor) / scaleFactor;
			motor[backLeft] = (50 - turnFactor) / scaleFactor;
			motor[backRight] = (50 + turnFactor) / scaleFactor;
		}
		else
		{
			motor[frontLeft] = (-50 - turnFactor);
			motor[frontRight] = (-50 + turnFactor);
			motor[backLeft] = (-50 - turnFactor);
			motor[backRight] = (-50 + turnFactor);
		}
	}
}
void turn(int turnFactor, int encoderDist)
{
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	speed = BOUND((int)encoderDist * kpd, -50, 50);	//We don't need to calc distError b/c encoders are 0 rn
	motor[frontLeft] = speed * turnFactor;	//Not to be confused with the PID turnFactor in moveStraight()
	motor[frontRight] = -speed * turnFactor;
	motor[backLeft] = speed * turnFactor;
	motor[backRight] = -speed * turnFactor;
	while(nMotorRunState[frontLeft] != runStateIdle || nMotorRunState[frontRight] != runStateIdle)
	{
		//Subtract the two to find the average b/c they're going opposite directions
		distError = encoderDist - (nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom])/2;

		speed = BOUND((int)distError * kpd, -50, 50);	//We only needed turnFactor to kickstart the direction
		motor[frontLeft] = speed;
		motor[frontRight] = -speed;
		motor[backLeft] = speed;
		motor[backRight] = -speed;
	}
}
void trackForIR()
{
	int target = 5000;	//Adjust for how far to go forward before turning and starting to look for the next position
	for(int i = 0; i < 3; i++)
	{
		nMotorEncoder[liftLeftTop] = 0;
		nMotorEncoder[liftRightBottom] = 0;
		while(SensorValue[irSeeker] != 5 && (nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2 < target)
		{
			/** Copied and pasted from moveStraight(). We can't use that function because it would be too
			busy in the while loop in moveStraight() to check if the irSeeker is 5 yet**/
			if (abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) < controllable)
			{
				error = nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];

				integral += error;
				/**
				*
				* We can either "dampen" the integral term by multiplying it by 2/3, or we can set a limit
				*
				*  **/
				derivative = error - lastError;
				lastError = error;
				turnFactor = (int)((error * kp) + (integral * ki) + (derivative * kd));
			}
			else
			{
				turnFactor = 0;
			}
			distError = encoderDist - (nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2;

			speed = BOUND((int)distError * kpd, -75, 75);
			motor[frontLeft] = speed - turnFactor;
			motor[frontRight] = speed + turnFactor;
			motor[backLeft] = speed - turnFactor;
			motor[backRight] = speed + turnFactor;
		}
		if(SensorValue[irSeeker] == 5)	//The while loop could end without finding the IR, so check first.
		{
			//DO STUFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
		}
		else
		{
			turn(1, 5000);	//ADJUST DISTANCE TO TURN!
		}
		/*If the irSeeker isn't 5 (if the while loop ended because of the encoder-check), then just start
		tracking the next position (turn the repeat)*/
	}
}

//Gradually put the latch down
void latchDown()
{
	while(servo[latchRight] < 255)
	{
		servo[latchRight] = servo[latchRight] + 10;
		servo[latchLeft] = servo[latchLeft] - 10;
		wait1Msec(25);
	}
}

//Same, but reversed
void latchUp()
{
	while(servo[latchRight] > 0)
	{
		servo[latchRight] -= 1;
		servo[latchLeft] += 1;
		wait1Msec(25);
	}
}

//Do a smooth turn. True is right, false is left
void smoothTurn(bool turnRight)
{
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(nMotorEncoder[liftLeftTop] < 3000)
	{
		if(turnRight)
		{
			motor[frontLeft] = 20;
			motor[frontRight] = 10;
			motor[backLeft] = 20;
			motor[backRight] = 10;
		}
		else if(!turnRight)
		{
			motor[frontLeft] = 10;
			motor[frontRight] = 20;
			motor[backLeft] = 10;
			motor[backRight] = 20;
		}
	}
}

//Going down the ramp needs special attention b/c going at 50% speed with our weight, the robot jumps to the right a little
void downRamp()
{
	moveStraight(-20);
	moveStraight(-10, 4);
	moveStraight(-50);
}

int chooseStrategy()
{
	string displayStrategies[] = {
		"Strategy?",
		" 1: None",
		" 2: Points",
		" 3: Defend"
	};
	short currentSelectionStrat = 1;
	//Initialize the display and currentSelection inside the function so it doesn't take up space later

	eraseDisplay();
	for(int i=0; i < 4; i++)	//Clear screen, then display the "strategies" screen
	{
		nxtDisplayString(i, "%s", displayStrategies[i]);
	}
	wait1Msec(500);

	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 && currentSelectionStrat < 3)	//if right button, go down
		{
			currentSelectionStrat++;
			nxtDisplayString(currentSelectionStrat - 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionStrat, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		else if(nNxtButtonPressed == 2 && currentSelectionStrat > 1)	//if left button, go up
		{
			currentSelectionStrat--;
			nxtDisplayString(currentSelectionStrat + 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionStrat, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		wait1Msec(10);
	}
	return currentSelectionStrat;	//Return the number the person selected (corresponding to screen)
}

int chooseStart()
{
	string displayStart[] = {
		"Start Point?",
		" 1: Platform",
		" 2: Parking Zone"
	};
	short currentSelectionStart = 1;
	//Initialize the display and currentSelection inside the function so it doesn't take up space later

	eraseDisplay();
	for(int i=0; i < 3; i++)	//Clear screen, then display the "start" screen
	{
		nxtDisplayString(i, "%s", displayStart[i]);
	}
	wait1Msec(500);

	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 && currentSelectionStart < 2)	//if right button, go down
		{
			currentSelectionStart++;
			nxtDisplayString(currentSelectionStart - 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionStart, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		else if(nNxtButtonPressed == 2 && currentSelectionStart > 1)	//if left button, go up
		{
			currentSelectionStart--;
			nxtDisplayString(currentSelectionStart + 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionStart, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		wait1Msec(10);
	}
	return currentSelectionStart;	//Return the number the person selected (corresponding to screen)
}

int chooseGoals()
{
	string displayGoals[] = {
		"Which Goals?",
		" 1: 60cm",
		" 2: 30cm",
		" 3: Both",
		" 4: None"
	};
	short currentSelectionGoals = 1;
	//Initialize the display and currentSelection inside the function so it doesn't take up space later

	eraseDisplay();
	for(int i=0; i < 5; i++)	//Clear screen, then display the "goals" screen
	{
		nxtDisplayString(i, "%s", displayGoals[i]);
	}
	wait1Msec(500);

	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 && currentSelectionGoals < 4)	//if right button, go down
		{
			currentSelectionGoals++;
			nxtDisplayString(currentSelectionGoals - 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionGoals, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		else if(nNxtButtonPressed == 2 && currentSelectionGoals > 1)	//if left button, go up
		{
			currentSelectionGoals--;
			nxtDisplayString(currentSelectionGoals + 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionGoals, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		wait1Msec(10);
	}
	return currentSelectionGoals;	//Return the number the person selected (corresponding to screen)
}

int chooseDelays()
{
	string displayDelays[] = {
		"Delay?",
		" 1: 0 sec",
		" 2: 1 sec",
		" 3: 4 sec",
		" 4: 9 sec",
		" 5: 16 sec"
	};
	short currentSelectionDelays = 1;
	//Initialize the display and currentSelection inside the function so it doesn't take up space later

	eraseDisplay();
	for(int i=0; i < 6; i++)	//Clear screen, then display the "delays" screen
	{
		nxtDisplayString(i, "%s", displayDelays[i]);
	}
	wait1Msec(500);

	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 && currentSelectionDelays < 5)	//if right button, go down
		{
			currentSelectionDelays++;
			nxtDisplayString(currentSelectionDelays - 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionDelays, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		else if(nNxtButtonPressed == 2 && currentSelectionDelays > 1)	//if left button, go up
		{
			currentSelectionDelays--;
			nxtDisplayString(currentSelectionDelays + 1, " ");	//Erase the ">" in the last line
			nxtDisplayString(currentSelectionDelays, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		wait1Msec(10);
	}
	return (currentSelectionDelays - 1) * (currentSelectionDelays - 1);	//Return delay before starting (regarding the selected number)
}

bool isTestRun()
{
	string displayTestRun[] = {
		"Test Run?",
		" 1: No",
		" 2: Yes"
	};
	bool currentSelection = false;
	//Initialize the display and currentSelection inside the function so it doesn't take up space later

	eraseDisplay();
	for(int i=0; i < 3; i++)	//Clear screen, then display the "delays" screen
	{
		nxtDisplayString(i, "%s", displayTestRun[i]);
	}
	wait1Msec(500);

	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 && currentSelection == true)	//if right button, go down
		{
			currentSelection = !currentSelection;
			nxtDisplayString(1, " ");	//Erase the ">" in the last line
			nxtDisplayString(2, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		else if(nNxtButtonPressed == 2 && currentSelection == false)	//if left button, go up
		{
			currentSelection--;
			nxtDisplayString(2, " ");	//Erase the ">" in the last line
			nxtDisplayString(1, ">");	//Add the ">" in the current line
			wait1Msec(250);
		}
		wait1Msec(10);
	}
	return currentSelection;	//Return true/false depending on what's selected
}
