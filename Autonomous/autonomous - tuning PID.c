#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     liftLeftBottom, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     liftLeftTop,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftRightTop,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     liftRightBottom, tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    latchRight,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    latchLeft,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    intakeLeft,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_4,    intakeRight,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define BOUND(num, low, high) (num < low) ? low : ((num > high) ? high : num)   //We don't want to set the motors higher than -100 or 100, so limit it!
const float ENCODER_TICKS_PER_INCH = 152.788745368;
const int perfect90 = 1980; // [16.5 inches * pi (circle that a point turn makes) / 4 (90 degrees is 360 degrees divided by 4)] * ENCODER_TICKS_PER_INCH

int speed = 0;
int error = 0, distError = 0;

float kp = .7;	//Proportional constant factor for going straight
float ki = .001;	//Integral constant factor for going straight
float kd = 1.5;	//Derivital constant factor for going straight
int lastError = 0;	//Stores the last error, used for the dervitive portion of PID
int integral = 0;	//Stores the sum of all past errors, used for the integral portion of PID
int maxIntegral = 1000000;	//Max integral amount before it resets
int turnFactor = 0;	//How much to correct the error (not driving straight)
int tolerance = 25;	//How much of a difference in the encoder values is allowed. Is this considered "straight" enough??
int derivative = 0;	//Stores the change in error (errorS - lastErrorS). We don't need to divide by time because time is constant

const float kpd = 1;	//Proportional constant factor for going a certain distance
const float kdd = 0;	//Derivital constant factor for going a certain distance
int lastErrorD = 0;	//Stores the last error, used for the dervitive portion of PID
int derivativeD = 0;	//Stores the change in error (errorD - lastErrorD)
//** for measuring distance, integral portion is not really needed **\\

bool get90Cm = false;
int platformStart = -32;	//If we start on the top of the platform, then add 5in when getting to the rolling goal
int waitTimes[] = {0, 0};	//Wait times so we can adapt to other teams' autonomous

void moveStraight(int distInInches)
{
	int turnFactor = 0;
	int encoderDist = distInInches * ENCODER_TICKS_PER_INCH;
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	speed = BOUND((int)encoderDist * kpd, -75, 75);	//We don't need to calc distError b/c encoders are 0 rn
	motor[frontLeft] = speed;
	motor[frontRight] = speed;
	motor[backLeft] = speed;
	motor[backRight] = speed;
	//while(nMotorRunState[frontLeft] != runStateIdle || nMotorRunState[frontRight] != runStateIdle)
	//{
	while(abs((nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2) < abs(encoderDist) && joy1Btn(1)==0)	//While the average is not yet at the setpoint
	{
		//Only do PID if the motors are within the controllable range
		if (abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) < 3000 && abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) > 50)
		{
			//Error is the difference between the encoders
			error = nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];

			integral += error;	//Add error to integral
			if(integral > 2000) integral = 2000;
			else if(integral < -2000) integral = -2000;	//Limit the integral
				//integral = (int)((integral * 2/3) + error);	//Dampen integral and add error
			/**
			*
			* We can either "dampen" the integral term by multiplying it by 2/3, or we can set a limit
			*
			*  **/
			derivative = error - lastError;	//Find the slope (rate of change)
			lastError = error;	//Update lastError for the next run-thru

			//Add the P.I.D terms to determine how much to turn the robot to get it to go straight
			turnFactor = (int)((error * kp) + (integral * ki) + (derivative * kd));
		}
		else
		{
			turnFactor = 0;
		}
		//Error of distance is the (set point - average of encoders)
		distError = encoderDist - (nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2;

		speed = BOUND((int) distError * kpd, -50, 50);	//Limit so we have some room for the turnFactor
		/*Since turnFactor is basically the difference between the left and right motors, we'll
		add it to the right motors and subtract it from the left motors. When inversed, it'll still work*/
		if(sgn(encoderDist)==1)
		{
			motor[frontLeft] = (50 - turnFactor);
			motor[frontRight] = (50 + turnFactor);
			motor[backLeft] = (50 - turnFactor);
			motor[backRight] = (50 + turnFactor);
		}
		else
		{
			motor[frontLeft] = (-50 - turnFactor);
			motor[frontRight] = (-50 + turnFactor);
			motor[backLeft] = (-50 - turnFactor);
			motor[backRight] = (-50 + turnFactor);
		}
		nxtDisplayString(2, "LEnc: %5d", nMotorEncoder[liftLeftTop]);
		nxtDisplayString(3, "REnc: %5d", nMotorEncoder[liftRightBottom]);
		nxtDisplayString(4, "Error: %4d", error);
		nxtDisplayString(5, "DError: %4d", distError);
		nxtDisplayString(6, "Turn: %4d", turnFactor);
	}
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}

task main()
{
	stopTask(displayDiagnostics);
	eraseDisplay();
	while (true)
	{
		getJoystickSettings(joystick);

		if(joy1Btn(5)==1)
		{
			moveStraight(40);
			} else if(joy1Btn(7)==1) {
			moveStraight(-40);
		}
		if(joy1Btn(4)==1)
		{
			//kp = kp + .25;
			//ki += .001;
			kd += .1;
			//nxtDisplayString(1, "kps: %2.2f", kp);
			//	nxtDisplayString(1, "ki: %2.3f", ki);
			nxtDisplayString(1, "kd: %2.2f", kd);
		}
		if(joy1Btn(2)==1)
		{
			//kp = kp - .25;
			//ki -= .001;
			kd -= .1;
			//nxtDisplayString(1, "kps: %2.2f", kp);
			//nxtDisplayString(1, "ki: %2.3f", ki);
			nxtDisplayString(1, "kd: %2.2f", kd);
		}
		if(joy1Btn(6)==1)
		{
			motor[liftLeftBottom] = 70;
			motor[liftLeftTop] = -70;	//Reversed b/c the encoders are plugged in weird (left front encoder is plugged into this)
			motor[liftRightBottom] = 50;
			motor[liftRightTop] = 50;
		}
		else
		{
			motor[liftLeftBottom] = 0;
			motor[liftLeftTop] = 0;
			motor[liftRightBottom] = 0;
			motor[liftRightTop] = 0;
		}
		wait1Msec(250);
	}
}
