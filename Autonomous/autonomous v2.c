#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touch,          sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     liftLeftBottom, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     liftLeftTop,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     frontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftRightTop,  tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     liftRightBottom, tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C1_1,    latchRight,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    latchLeft,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    intakeLeft,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_4,    intakeRight,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Janurary 20th, 2014
Chris: ZOMGGGGGGG PID GOGOGO YAS. Spent the bus-ride to West Valley HS in Hemet making the PID stuff, then we took 5ever
tuning it. Took out integral because it's straight /enough/ for autonomous to work most of the time. We'll tune it when
we get back to Heritage. BUT YAS. Also, changed lError and rError to be averaged, so the motors are set to the same speed.
Also, slowed down the robot, because tuning would've been horrendous^2 if we tried to make it go fast. CONTROL AWARD
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define BOUND(num, low, high) (num < low) ? low : ((num > high) ? high : num)   //We don't want to set the motors higher than -100 or 100, so limit it!
const float ENCODER_TICKS_PER_INCH = 152.788745368;
const int perfect90 = 1980; // [16.5 inches * pi (circle that a point turn makes) / 4 (90 degrees is 360 degrees divided by 4)] * ENCODER_TICKS_PER_INCH


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servo[latchLeft] = 200;
	servo[latchRight] = 55;
	servo[intakeLeft] = 127;
	servo[intakeRight] = 127; /* motor[liftLeftTop] = 30;
	motor[liftLeftBottom] = 30;
	motor[liftRightTop] = 60;
	motor[liftRightBottom] = 60;
	wait1Msec(500);
	motor[liftLeftTop] = 0;
	motor[liftLeftBottom] = 0;
	motor[liftRightTop] = 0;
	motor[liftRightBottom] = 0;*/
	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
int lSpeed = 0, rSpeed = 0;
int lError = 0, rError = 0, errorS = 0;

const float kps = .25;	//Proportional constant factor for going straight
const float kis = 0;	//Integral constant factor for going straight
const float kds = 0;	//Derivital constant factor for going straight
int lastErrorS = 0;	//Stores the last error, used for the dervitive portion of PID
int integralS = 0;	//Stores the sum of all past errors, used for the integral portion of PID
int maxIntegralS = 1000000;	//Max integral amount before it resets
int turnPower = 0;	//How much to correct the error (not driving straight)
int tolerance = 25;	//How much of a difference in the encoder values is allowed. Is this considered "straight" enough??
int derivativeS = 0;	//Stores the change in error (errorS - lastErrorS). We don't need to divide by time because time is constant

const float kpd = 1;	//Proportional constant factor for going a certain distance
const float kdd = 0;	//Derivital constant factor for going a certain distance
int lastErrorD = 0;	//Stores the last error, used for the dervitive portion of PID
int derivativeD = 0;	//Stores the change in error (errorD - lastErrorD)
//** for measuring distance, integral portion is not really needed **\\

bool get90Cm = false;
int platformStart = -32;	//If we start on the top of the platform, then add 5in when getting to the rolling goal
int waitTimes[] = {0, 0};	//Wait times so we can adapt to other teams' autonomous

bool PID = false;
task tuneVariables()
{
	while(true)
	{
		if(joy1Btn(1)==1)
		{
			PID = !PID;
		}
		if(joy1Btn(4)==1)
		{
			//	kps++;
			nxtDisplayString(2, "kps: %2.2f", kps);
		}
		if(joy1Btn(2)==1)
		{
			//	kps--;
			nxtDisplayString(2, "kps: %2.2f", kps);
		}
		wait1Msec(250);
	}
}
void moveStraight(int distInInches)
{
	int encoderDist = distInInches * ENCODER_TICKS_PER_INCH;
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(abs(nMotorEncoder[liftLeftTop]) < abs(encoderDist) && abs(nMotorEncoder[liftRightBottom]) < abs(encoderDist)
	{
		if(abs(nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom]) > tolerance)
		{
			errorS	= nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];
			} else {
			integralS = 0;	//Reset the sum of past errors when close to being straight
		}
		if(integralS > maxIntegralS)
		{
			integralS = 0;	//Reset the integral if it gets too high
		}
		turnPower = (int)((errorS * kps) + (integralS * kis) + (derivativeS * kds));
		derivativeS = errorS - lastErrorS;	//Find change in error
		lastErrorS = errorS;	//Update lastErrorS to be the lastest error so we can use it for the next run-thru
		integralS += errorS;	/*Add the error to the integral (sum of all past errors). Should we multiply it by a fraction (2/3)
		so it'll start "erasing" past memory, or dampening it?*/

	/*	lError = encoderDist - nMotorEncoder[liftLeftTop];
		rError = encoderDist - nMotorEncoder[liftRightBottom];*/
		lError = encoderDist - ((nMotorEncoder[liftLeftTop] + nMotorEncoder[liftRightBottom])/2);	//Set both motors to average of encoders

		lSpeed = BOUND((int)(lError * kpd), -25, 25);
		rSpeed = BOUND((int)(lError * kpd), -25, 25);
		motor[frontLeft] = lSpeed;
		motor[backLeft] = lSpeed;	/*Subtract the turnPower from left rather than add it to right
		because they'll mainly already be at full power. Also, we subtract from the final speed because we want to see a difference
		even when the motors are at full power (turnPower would've been factored into the proportional controller for measuring
		disance)*/
		motor[frontRight] = rSpeed + turnPower;
		motor[backRight] = rSpeed + turnPower;
		nxtDisplayString(0, "LEnc: %5d", nMotorEncoder[liftLeftTop]);
		nxtDisplayString(1, "REnc: %5d", nMotorEncoder[liftRightBottom]);
	}
}

void selectStart()
{
	nxtDisplayString(0, "Platform Position?");
	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2)
		{
			if(platformStart == 0) platformStart = 5;
			else platformStart = 0;
			if(platformStart == 0) nxtDisplayString(1, "!Top");
			else nxtDisplayString(1, "!Bottom");
			wait1Msec(250);
		}
		wait1Msec(250);
	}
	nxtDisplayString(1, ">"); //Change from "!Platform" to ">Platform"

	wait1Msec(500);

	nxtDisplayString(3, "Get 90cm?");
	while(nNxtButtonPressed != 3)
	{
		if(nNxtButtonPressed == 1 || nNxtButtonPressed == 2)
		{
			get90Cm = !get90Cm;
			if(get90Cm == true) nxtDisplayString(4, "!Yes");
			else nxtDisplayString(1, "!No");
			wait1Msec(250);
		}
		wait1Msec(250);
	}
	nxtDisplayString(4, ">");
}

void selectWaitTimes()
{
	for(int onArrayIndex = 0; onArrayIndex < 2; onArrayIndex++)
	{
		nxtDisplayString(onArrayIndex, "Wait how long?");
		while(nNxtButtonPressed != 3)
		{
			if(nNxtButtonPressed == 1)
			{
				waitTimes[onArrayIndex]++;  //divide by 2 so indexes are (0 [0/2], 1 [2/2], 2 [4/2], 3 [6/2], 4 [8/2], & 5 [10/2])
				nxtDisplayString(onArrayIndex + 1, "Wait %d seconds", waitTimes[onArrayIndex]);
				wait1Msec(250);
				} else if(nNxtButtonPressed == 2) {
				waitTimes[onArrayIndex]--;
				nxtDisplayString(onArrayIndex + 1, "Wait %d seconds", waitTimes[onArrayIndex]);
				wait1Msec(250);
			}
		}
		wait1Msec(500);
	}
}

task main()
{
	stopTask(displayDiagnostics);
	eraseDisplay();
	initializeRobot();
	//	selectStart();
	//selectWaitTimes();
	startTask(displayDiagnostics);

	//int target = -13680;
	int target = -8000;
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;

	//waitForStart();
	motor[liftLeftTop] = 30;
	motor[liftLeftBottom] = 30;
	motor[liftRightTop] = 60;
	motor[liftRightBottom] = 60;
	wait1Msec(500);
	motor[liftLeftTop] = 0;
	motor[liftLeftBottom] = 0;
	motor[liftRightTop] = 0;
	motor[liftRightBottom] = 0;
	/*
	lError = target - nMotorEncoder[liftLeftTop];
	rError = target - nMotorEncoder[liftRightBottom];

	lSpeed = BOUND(lError / kp, -100, 100);
	rSpeed = BOUND(rError / kp, -100, 100);
	motor[frontLeft] = lSpeed;
	motor[frontRight] = rSpeed;
	motor[backLeft] = lSpeed;
	motor[backRight] = rSpeed;*/

	wait1Msec(waitTimes[0]);
	if(get90Cm)
	{
		moveStraight(-60 + platformStart);
		} else {
		moveStraight(-54 + platformStart);	//Backwards 54 inches
	}
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;

	while(servo[latchRight] < 255)
	{
		servo[latchRight] = servo[latchRight] + 10;
		servo[latchLeft] = servo[latchLeft] - 10;
		nxtDisplayString(1, "RServo: %2d", servo[latchRight]);
		nxtDisplayString(2, "LServo: %2d", servo[latchLeft]);
		wait1Msec(25);
	}
	/*
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(nMotorEncoder[liftLeftTop] > -6750 || nMotorEncoder[liftRightBottom] < 6750)
	{
	if(nMotorEncoder[liftLeftTop] != -nMotorEncoder[liftRightBottom])
	{
	error	= nMotorEncoder[liftLeftTop] - nMotorEncoder[liftRightBottom];
	}
	lError = 6750 - nMotorEncoder[liftLeftTop];
	rError = 6750 - nMotorEncoder[liftRightBottom] + error;
	lSpeed = BOUND(lError / kp, -100, 100);
	rSpeed = BOUND(rError / kp, -100, 100);

	motor[frontLeft] = -lSpeed;
	motor[frontRight] = rSpeed;
	motor[backLeft] = -lSpeed;
	motor[backRight] = rSpeed;
	}*/

//	wait1Msec(waitTimes[1]);
	wait1Msec(10000);
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(nMotorEncoder[liftLeftTop] < 2500)
	{
		lError = 2500 - nMotorEncoder[liftLeftTop];

		//	derivativeD = lError - lastErrorD;
		//	lSpeed = BOUND((int)((lError * kpd) + (derivativeD * kdd)), -50, 50);
		lSpeed = BOUND((int)(lError * kpd), -50, 50);
		motor[frontLeft] = lSpeed;
		motor[backLeft] = lSpeed;
		motor[frontRight] = 0;
		motor[backRight] = 0;
	}
	moveStraight(25);
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(nMotorEncoder[liftRightBottom] < 2500)
	{
		rError = 2500 - nMotorEncoder[liftRightBottom];

	//	derivativeD = rError - lastErrorD;
	//	rSpeed = BOUND((int)((rError * kpd) + (derivativeD * kdd)), -50, 50);
	rSpeed = BOUND((int)(rError * kpd), -50, 50);
		motor[frontRight] = rSpeed;
		motor[backRight] = rSpeed;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
	moveStraight(55);
	nMotorEncoder[liftLeftTop] = 0;
	nMotorEncoder[liftRightBottom] = 0;
	while(abs(nMotorEncoder[liftRightBottom]) < 4000)
	{
		rError = 4000 - nMotorEncoder[liftLeftTop];

		rSpeed = BOUND((int)(rError * kpd), -50, 50);
		motor[frontRight] = rSpeed;
		motor[backRight] = rSpeed;
		motor[frontLeft] = -rSpeed;
		motor[backLeft] = -rSpeed;
	}
	moveStraight(-2);
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
	while (true)
	{}
}
